import java.math.BigDecimal
import java.math.MathContext
import java.util.*
import kotlin.collections.HashMap

class DataLearner {
    class MalwareLearner(val set:List<BaseApp>) {
        private val numberByType: MutableMap<String, Int> = HashMap()
        private val probByType: MutableMap<String, BigDecimal> = HashMap()
        private val probFeatureByType: MutableMap<String, MutableMap<String, BigDecimal>> = HashMap()
        private val listFeatures: MutableMap<String, LinkedList<String>> = HashMap()
        private var listFeaturesDistinct: MutableMap<String, List<String>> = HashMap()
        private val classes: MutableList<String> = LinkedList()
        init {
            for (app in set) {
                if (classes.contains(app.type)) continue
                else classes.add(app.type)
            }
            listFeatures["_all_"] = LinkedList()
            for (type in classes) {
                numberByType[type] = set.filter{it.type == type}.size
                probByType[type] = BigDecimal(numberByType[type]!!.toDouble() / set.size)
                probFeatureByType[type] = HashMap()
                listFeatures[type] = LinkedList()
            }
            for (app in set) {
                val map = app.features
                map.forEach { _, u ->
                    listFeatures[app.type]?.addAll(u)
                    listFeatures["_all_"]?.addAll(u)
                }
            }

            for (type in classes) {
                listFeaturesDistinct[type] = listFeatures[type]!!.distinct()
            }
            listFeaturesDistinct["_all_"] = listFeatures["_all_"]!!.distinct()
        }


        fun classify (app: BaseApp): String {
            val resultsProbability : MutableMap<String, BigDecimal?> = HashMap()
            val featureSet: List<String> = app.features.values.flatten()
            classes.forEach{type ->
                var probIsType: BigDecimal? = probByType[type]
                for (feature in featureSet) {
                    val probWordByType = probFeatureByType[type]!![feature] ?: continue
                    probIsType = probIsType?.multiply(probWordByType)
                }
                resultsProbability[type] = probIsType
            }

            var max = BigDecimal(-1)
            var maxType : String? = null
            resultsProbability.forEach { t, u ->
                if (u!! > max) {
                    max = u
                    maxType = t
                }
            }
            return maxType!!
        }

        fun learn(type: Int) {
            if(type == 0) learnBernouille()
            else leanMultinomial()
        }

        @Synchronized fun learnBernouille() {
            classes.forEach { type ->
                listFeaturesDistinct["_all_"]!!.forEach { feature ->
                    val numberElementsWithFeature = set.filter {it.type == type && containsFeature(feature, it.features) }.size
                    probFeatureByType[type]!![feature] = BigDecimal(numberElementsWithFeature + 1.0).divide(BigDecimal(numberByType[type]!! + 2), MathContext.DECIMAL128)
                }
            }
        }

        @Synchronized fun leanMultinomial() {
            classes.forEach { type ->
                listFeaturesDistinct["_all_"]!!.forEach { feature ->
                    val tfc = listFeatures[type]!!.filter { it == feature }.size
                    probFeatureByType[type]!![feature] = BigDecimal(tfc + 1.0).divide(BigDecimal(listFeatures[type]!!.size + listFeaturesDistinct["_all_"]!!.size), MathContext.DECIMAL128)
                }
            }
        }


        private fun containsFeature(feature: String, map : Map<String, List<String>>): Boolean {
            for (key in map.keys) {
                if (map[key]!!.contains(feature)) return true
            }
            return false
        }
    }
}