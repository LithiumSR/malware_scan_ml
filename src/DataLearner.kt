import java.math.BigDecimal
import java.math.MathContext
import java.util.*
import kotlin.collections.HashMap

class DataLearner {

    class MalwareLearner(val set:List<BaseApp>) {
        private val numberByType: MutableMap<String, Int> = HashMap()
        private val probByType: MutableMap<String, BigDecimal> = HashMap()
        private val probFeatureByType: MutableMap<String, MutableMap<String, BigDecimal>> = HashMap()
        private val listFeaturesMalware: MutableList<String> = LinkedList()
        private val listFeaturesGenuine: MutableList<String> = LinkedList()
        private var listFeaturesMalwareDistinct: List<String> = LinkedList()
        private var listFeaturesGenuineDistinct: List<String> = LinkedList()
        private var allFeaturesDistinct: List<String> = LinkedList()
        private val allFeatures: MutableList<String> = LinkedList()

        init {
            val numberOfMalwares = set.filter { it.isMalware }.size
            numberByType["malware"] = numberOfMalwares
            numberByType["genuine"] = set.size - numberOfMalwares
            probByType["malware"] = BigDecimal(numberByType["malware"]!!.toDouble() / set.size)
            probByType["genuine"] = BigDecimal(numberByType["genuine"]!!.toDouble() / set.size)
            probFeatureByType["malware"] = HashMap()
            probFeatureByType["genuine"] = HashMap()
            for (prog in set) {
                val map = prog.features
                map.forEach { _, u ->
                    if (prog.isMalware) {
                        listFeaturesMalware.addAll(u)
                        allFeatures.addAll(u)
                    } else {
                        listFeaturesGenuine.addAll(u)
                        allFeatures.addAll(u)
                    }
                }
            }
            listFeaturesGenuineDistinct = listFeaturesGenuine.distinct()
            listFeaturesMalwareDistinct = listFeaturesMalware.distinct()
            allFeaturesDistinct = allFeatures.distinct()
        }


        fun classify (app: BaseApp): Boolean {
            var probIsMalware: BigDecimal? = probByType["malware"]
            var probIsGenuine: BigDecimal? = probByType["genuine"]
            val featureSet: List<String> = app.features.values.flatten()
            if (app.isMalware) println("Start $probIsMalware $probIsGenuine")
            for (feature in featureSet) {
                val probWordMalware = probFeatureByType["malware"]!![feature]
                val probWordGenuine = probFeatureByType["genuine"]!![feature]
                if (app.isMalware) println("Meantime word $feature prob $probWordMalware $probWordGenuine")
                if (probWordMalware == null || probWordGenuine == null) continue
                probIsMalware = probIsMalware?.multiply(probWordMalware)
                probIsGenuine = probIsGenuine?.multiply(probWordGenuine)

            }
            if (app.isMalware) println("End $probIsMalware $probIsGenuine")
            return if (probIsMalware == probIsGenuine) probByType["malware"]!! > probByType["genuine"]
            else probIsMalware!! > probIsGenuine
        }

        fun learn(type: Int) {
            if(type == 0) learnBernouille()
            else leanMultinomial()
        }

        @Synchronized fun learnBernouille() {
            for (feature in allFeaturesDistinct) {
                var numberMalwareWithFeature = 0
                var numberGenuineWithFeature = 0
                for (element in set) {
                    if (!containsFeature(feature, element.features)) continue
                    if (element.isMalware) numberMalwareWithFeature++
                    if (!element.isMalware) numberGenuineWithFeature++
                }
                assert(numberGenuineWithFeature == numberMalwareWithFeature && numberGenuineWithFeature == 0)
                probFeatureByType["malware"]!![feature] = BigDecimal(numberMalwareWithFeature+1).divide(BigDecimal(numberByType["malware"]!!+2), MathContext.DECIMAL128)
                probFeatureByType["genuine"]!![feature] = BigDecimal(numberGenuineWithFeature+1).divide(BigDecimal(numberByType["genuine"]!!+2), MathContext.DECIMAL128)
            }
        }

        @Synchronized fun leanMultinomial() {
            for (feature in allFeaturesDistinct) {
                val tfm = listFeaturesMalware.filter { it == feature }.size
                val tfg = listFeaturesGenuine.filter { it == feature }.size
                probFeatureByType["malware"]!![feature] = BigDecimal(tfm+1.0).divide(BigDecimal(listFeaturesMalware.size + allFeaturesDistinct.size), MathContext.DECIMAL128)
                probFeatureByType["genuine"]!![feature] = BigDecimal(tfg+1.0).divide(BigDecimal(listFeaturesGenuine.size + allFeaturesDistinct.size), MathContext.DECIMAL128)
            }
        }


    fun containsFeature(feature: String, map : Map<String, List<String>>): Boolean {
        for (key in map.keys) {
            if (map[key]!!.contains(feature)) return true
        }
        return false
    }
}
}